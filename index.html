<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#1a1a1a">
    <title>Remote Chess</title>
    <link rel="manifest" href="manifest.json">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #1a1a1a;
            color: #fff;
            overflow: hidden;
            touch-action: none;
        }

        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
        }

        #status {
            text-align: center;
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            margin-bottom: 10px;
        }

        #status-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #ff4444;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }

        #status-indicator.connected {
            background: #44ff44;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #board-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
        }

        #board {
            width: 100%;
            max-width: 400px;
            aspect-ratio: 1;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            background: #444;
            border: 3px solid #666;
            border-radius: 8px;
            padding: 2px;
        }

        .square {
            position: relative;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 32px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
        }

        .square.light {
            background: #f0d9b5;
        }

        .square.dark {
            background: #b58863;
        }

        .square.selected {
            background: #7fc97f !important;
        }

        .led-indicator {
            position: absolute;
            top: 3px;
            right: 3px;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: transparent;
            transition: background-color 0.2s;
            z-index: 10;
        }

        .led-indicator.red {
            background: #ff0000;
            box-shadow: 0 0 8px #ff0000;
        }

        .led-indicator.green {
            background: #00ff00;
            box-shadow: 0 0 8px #00ff00;
        }

        .led-indicator.blink {
            animation: blink 0.2s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .piece {
            width: 80%;
            height: 80%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 36px;
        }

        .piece.black {
            color: #000;
        }

        .piece.white {
            color: #fff;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
        }

        #controls {
            padding: 15px;
            background: #2a2a2a;
            border-radius: 10px;
            margin-top: 10px;
            display: flex;
            gap: 10px;
        }

        #controls button {
            flex: 1;
            margin: 0;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            color: #fff;
            cursor: pointer;
        }

        #disconnect-btn {
            background: #cc0000;
        }

        #disconnect-btn:active {
            background: #990000;
        }

        #reset-btn {
            background: #0066cc;
        }

        #reset-btn:active {
            background: #0052a3;
        }

        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="status">
            <span id="status-indicator"></span>
            <span id="status-text">Disconnected</span>
        </div>

        <div id="board-container">
            <div id="board"></div>
        </div>

        <div id="controls">
            <button id="disconnect-btn" style="display:none;">Disconnect</button>
            <button id="reset-btn">Neu starten</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/paho-mqtt/1.0.1/mqttws31.min.js"></script>
    <script>
        // MQTT Configuration (hardcoded)
        const MQTT_CONFIG = {
            broker: 'broker.hivemq.com',
            port: 8884,
            useSSL: true,
            topic: 'home/chess'
        };

        // Chess pieces as text labels
        const PIECE_LABELS = {
            '♔': { label: '♔', color: 'white' },
            '♕': { label: '♕', color: 'white' },
            '♖': { label: '♖', color: 'white' },
            '♗': { label: '♗', color: 'white' },
            '♘': { label: '♘', color: 'white' },
            '♙': { label: '♙', color: 'white' },
            '♚': { label: '♚', color: 'black' },
            '♛': { label: '♛', color: 'black' },
            '♜': { label: '♜', color: 'black' },
            '♝': { label: '♝', color: 'black' },
            '♞': { label: '♞', color: 'black' },
            '♟': { label: '♟', color: 'black' }
        };

        // Initial board setup
        const INITIAL_BOARD = [
            ['♜','♞','♝','♛','♚','♝','♞','♜'],
            ['♟','♟','♟','♟','♟','♟','♟','♟'],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['','','','','','','',''],
            ['♙','♙','♙','♙','♙','♙','♙','♙'],
            ['♖','♘','♗','♕','♔','♗','♘','♖']
        ];

        // Game state
        let board = JSON.parse(JSON.stringify(INITIAL_BOARD));
        let selectedSquare = null;
        let mqttClient = null;
        let isConnected = false;
        let ledStates = {};
        let sentMessages = new Set();
        let externalLiftCoord = null;
        let fadingTimer = null;

        // Initialize board UI
        function initBoard() {
            const boardEl = document.getElementById('board');
            boardEl.innerHTML = '';

            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const square = document.createElement('div');
                    const coord = String.fromCharCode(65 + col) + (8 - row);
                    
                    square.className = 'square ' + ((row + col) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = row;
                    square.dataset.col = col;
                    square.dataset.coord = coord;

                    // LED indicator
                    const led = document.createElement('div');
                    led.className = 'led-indicator';
                    led.dataset.coord = coord;
                    square.appendChild(led);

                    // Piece
                    const piece = document.createElement('div');
                    piece.className = 'piece';
                    const pieceSymbol = board[row][col];
                    if (pieceSymbol && PIECE_LABELS[pieceSymbol]) {
                        piece.textContent = PIECE_LABELS[pieceSymbol].label;
                        piece.classList.add(PIECE_LABELS[pieceSymbol].color);
                    }
                    square.appendChild(piece);

                    square.addEventListener('click', () => handleSquareClick(row, col, coord));
                    boardEl.appendChild(square);
                }
            }
        }

        // Handle square click
        function handleSquareClick(row, col, coord) {
            if (!isConnected) {
                addLog('Not connected to MQTT', 'error');
                return;
            }

            if (selectedSquare === null) {
                // Select piece
                if (board[row][col] !== '') {
                    selectedSquare = { row, col, coord };
                    document.querySelector(`[data-coord="${coord}"]`).classList.add('selected');
                    publishMove(coord + '-L');
                }
            } else {
                // Move piece
                const fromCoord = selectedSquare.coord;
                const toCoord = coord;

                // Update board
                board[row][col] = board[selectedSquare.row][selectedSquare.col];
                board[selectedSquare.row][selectedSquare.col] = '';

                // Clear selection
                document.querySelector(`[data-coord="${fromCoord}"]`).classList.remove('selected');
                selectedSquare = null;

                // Publish place
                publishMove(toCoord + '-P');

                // Update UI
                updateBoardUI();
            }
        }

        // Update board UI
        function updateBoardUI() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const coord = String.fromCharCode(65 + col) + (8 - row);
                    const square = document.querySelector(`[data-coord="${coord}"]`);
                    const piece = square.querySelector('.piece');
                    const pieceSymbol = board[row][col];
                    
                    piece.className = 'piece';
                    if (pieceSymbol && PIECE_LABELS[pieceSymbol]) {
                        piece.textContent = PIECE_LABELS[pieceSymbol].label;
                        piece.classList.add(PIECE_LABELS[pieceSymbol].color);
                    } else {
                        piece.textContent = '';
                    }
                }
            }
        }

        // Update LED indicator
        function updateLED(coord, color, blink = false) {
            const led = document.querySelector(`.led-indicator[data-coord="${coord}"]`);
            if (led) {
                led.className = 'led-indicator';
                if (color) {
                    led.classList.add(color);
                    if (blink) {
                        led.classList.add('blink');
                    }
                }
                ledStates[coord] = { color, blink };
            }
        }

        // Clear all LEDs
        function clearAllLEDs() {
            document.querySelectorAll('.led-indicator').forEach(led => {
                led.className = 'led-indicator';
            });
            ledStates = {};
        }

        // MQTT Functions
        function connectMQTT() {
            const { broker, port, topic, useSSL } = MQTT_CONFIG;

            const clientId = 'chess_pwa_' + Math.random().toString(16).substr(2, 8);
            const protocol = useSSL ? 'wss' : 'ws';
            
            addLog(`Connecting to ${protocol}://${broker}:${port}/mqtt`, 'info');
            
            try {
                mqttClient = new Paho.MQTT.Client(broker, port, '/mqtt', clientId);

                mqttClient.onConnectionLost = (responseObject) => {
                    if (responseObject.errorCode !== 0) {
                        addLog('Connection lost: ' + responseObject.errorMessage, 'error');
                        updateConnectionStatus(false);
                    }
                };

                mqttClient.onMessageArrived = (message) => {
                    handleMQTTMessage(message.payloadString);
                };

                const connectOptions = {
                    onSuccess: () => {
                        addLog('Connected to MQTT broker!', 'success');
                        updateConnectionStatus(true);
                        mqttClient.subscribe(topic);
                        addLog('Subscribed to ' + topic, 'success');
                    },
                    onFailure: (error) => {
                        addLog('Connection failed: ' + error.errorMessage, 'error');
                        updateConnectionStatus(false);
                        // Auto-retry after 5 seconds
                        setTimeout(connectMQTT, 5000);
                    },
                    useSSL: useSSL,
                    timeout: 10,
                    keepAliveInterval: 30
                };

                mqttClient.connect(connectOptions);
            } catch (error) {
                addLog('Error: ' + error.message, 'error');
                updateConnectionStatus(false);
            }
        }

        function disconnectMQTT() {
            if (mqttClient && isConnected) {
                mqttClient.disconnect();
                addLog('Disconnected from MQTT', 'info');
                updateConnectionStatus(false);
            }
        }

        function publishMove(message) {
            if (mqttClient && isConnected) {
                try {
                    sentMessages.add(message);
                    const mqttMessage = new Paho.MQTT.Message(message);
                    mqttMessage.destinationName = MQTT_CONFIG.topic;
                    mqttClient.send(mqttMessage);
                    addLog('Sent: ' + message, 'sent');
                } catch (error) {
                    addLog('Publish error: ' + error.message, 'error');
                }
            }
        }

        function handleMQTTMessage(message) {
            addLog('Received: ' + message, 'received');

            if (message.length < 4) return;

            const coord = message.substring(0, message.length - 2);
            const action = message.charAt(message.length - 1);

            // Check if this message was sent by us
            const isLocalMessage = sentMessages.has(message);
            if (isLocalMessage) {
                sentMessages.delete(message);
            }

            if (action === 'L') {
                // Lift
                clearAllLEDs();
                updateLED(coord, 'red', false);

                // Clear fading timer on new lift
                if (fadingTimer) {
                    clearTimeout(fadingTimer);
                    fadingTimer = null;
                }

                // Track external lift for piece movement
                if (!isLocalMessage) {
                    externalLiftCoord = coord;
                }
            } else if (action === 'P') {
                // Place
                updateLED(coord, 'green', false);

                // If external move, update board
                if (!isLocalMessage && externalLiftCoord) {
                    const fromCol = externalLiftCoord.charCodeAt(0) - 65;
                    const fromRow = 8 - parseInt(externalLiftCoord.charAt(1));
                    const toCol = coord.charCodeAt(0) - 65;
                    const toRow = 8 - parseInt(coord.charAt(1));

                    board[toRow][toCol] = board[fromRow][fromCol];
                    board[fromRow][fromCol] = '';
                    updateBoardUI();
                    externalLiftCoord = null;
                }

                // Start 20s fading timer
                if (fadingTimer) {
                    clearTimeout(fadingTimer);
                }
                fadingTimer = setTimeout(() => {
                    clearAllLEDs();
                    fadingTimer = null;
                }, 20000);
            } else if (action === 'X') {
                // Killed
                updateLED(coord, 'red', true);
            }
        }

        function updateConnectionStatus(connected) {
            isConnected = connected;
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            const disconnectBtn = document.getElementById('disconnect-btn');

            if (connected) {
                indicator.classList.add('connected');
                text.textContent = 'Connected';
                disconnectBtn.style.display = 'block';
            } else {
                indicator.classList.remove('connected');
                text.textContent = 'Disconnected';
                disconnectBtn.style.display = 'none';
            }
        }

        function addLog(message, type = 'info') {
            console.log(`[${type}] ${message}`);
        }

        function resetBoard() {
            board = JSON.parse(JSON.stringify(INITIAL_BOARD));
            selectedSquare = null;
            updateBoardUI();
            clearAllLEDs();
            addLog('Board reset', 'info');
        }

        // Event listeners
        document.getElementById('disconnect-btn').addEventListener('click', disconnectMQTT);
        document.getElementById('reset-btn').addEventListener('click', resetBoard);

        // Initialize
        initBoard();
        addLog('Chess PWA ready', 'info');
        
        // Auto-connect on load
        connectMQTT();
    </script>
</body>
</html>